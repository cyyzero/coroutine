# coroutine

试着实现简单的非对称有栈协程（实现得很丑陋...）。目前只支持x86_64架构，而且还未hook系统函数。

参考了[云风的实现](https://github.com/cloudwu/coroutine/)。我并未使用glibc提供的上下文切换的函数(那几个`xxxcontext`)，因为这个包括浮点、信号mask的保存，实际上很多时候只要对通用寄存器进行保存就够了。而且我并没有共享栈，每个线程自己独有一个栈，切换时不需要拷贝栈，用空间换时间。

## 实现细节

协程切换时，最重要的就是调用栈(`rsp`作为栈顶指针、一般`rbp`也会作为帧指针)和执行流(`rip`)的切换。此外还需要保存计算的状态，既其他一些寄存器。我是保存了X64上所有的通用寄存器。但其实根据具体的calling convention，有些寄存器归callee，有些归caller，有些归callee和caller共享。理论上应该保存callee和caller共享的那几个寄存器就够了。有空再根据System V ABI来优化下吧。实现的代码在函数`context_swap`中。

另外就是每个协程任务结束退出的时候，需要释放空间，当然也包括当前协程申请的用作栈的内存。但此时这个栈还在使用，所以在调用`co_delete`函数释放前，得将当前栈帧进行切换。我这里是默认rbp作为帧指针(但实际上可能不需要，所以可移植性很差)，将rbp和rsp之间的内存，以及rsp下128字节的red zone，复制到临时的栈。具体可以查看`main_func`函数。
